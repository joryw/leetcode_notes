## 构建树

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        return Helper(preorder, 0, 0, inorder.length - 1);
    }

    public TreeNode Helper(int[] preorder, int cur, int left, int right) {
        if(left > right) {
            return null;
        }

        TreeNode root = new TreeNode(preorder[cur]);
        int mid = map.get(preorder[cur]);
        root.left = Helper(preorder, cur + 1, left, mid - 1);
        root.right = Helper(preorder, cur + mid - left + 1, mid + 1, right);
        return root;
    }
}
```

##### 思路

1. 把inorder用map作为媒介，存储起来，中序的特点在于，找到根，则左边为左子树，右边为右子树。
2. 利用前序建立root过程中左右子树。
   1. 左子树：cur为当前节点的下一个节点，起点不变为left，终点为利用中序找到的根位置 - 1。
   2. 右子树，中序找到根位置mid，再-left位置，为左子树的长度范围，cur为上一节点根节点，+1为跳过当前根节点。   所以是cur + (mid-left) + 1

### [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return constructMaximumBinaryTree(nums, 0, nums.length - 1);
    }

    public TreeNode constructMaximumBinaryTree(int[] nums, int left, int right) {
        if(left > right) {
            return null;
        }
        int mid = getMax(nums, left, right);
        TreeNode root = new TreeNode(nums[mid]);
        root.left = constructMaximumBinaryTree(nums, left, mid - 1);
        root.right = constructMaximumBinaryTree(nums, mid + 1, right);
        return root;
    }

    public int getMax(int[] nums, int left, int right) {
        //注意max的取值，保险起见用最小值
        int max = Integer.MIN_VALUE, inx = 0;
        for(int i = left; i <= right; i++) {
            if(nums[i] > max) {
                max = nums[i];
                inx = i;
            }
        }
        return inx;
    }
}
```

##### 思路

按照题目描述的去处理即可

1. 辅助函数增加变量left、right
2. mid为当前left、right中最大值的索引位置，用getMax函数实现，作为root的值
3. 递归构建左右子树

