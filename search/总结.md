# 总结

### bfs&dfs选择

1.如果只是要找到某一个结果是否存在，那么DFS会更高效。因为DFS会首先把一种可能的情况尝试到底，才会回溯去尝试下一种情况，只要找到一种情况，就可以返回了。但是BFS必须所有可能的情况同时尝试，在找到一种满足条件的结果的同时，也尝试了很多不必要的路径；
2.如果是要找所有可能结果中最短的，那么BFS回更高效。因为DFS是一种一种的尝试，在把所有可能情况尝试完之前，无法确定哪个是最短，所以DFS必须把所有情况都找一遍，才能确定最终答案（DFS的优化就是剪枝，不剪枝很容易超时）。而BFS从一开始就是尝试所有情况，所以只要找到第一个达到的那个点，那就是最短的路径，可以直接返回了，其他情况都可以省略了，所以这种情况下，BFS更高效。

### 并查集

#### 优化

并查集一般有两种优化，这里规范一下表达：

「路径压缩」：在并查集中查找代表元素时，会将经过的所有元素「直接」连接到代表元素，也就是将连通分量「压扁」。

「按秩合并」：在并查集中合并两个连通分量时，将「秩」小的连通分量合并到「秩」大的连通分量上面。这里「秩」可以定义为连通分量的大小（包含的节点数量），或者连通分量的高度（连通分量是树的结构，因此可以定义高度。不过在「路径压缩」优化的基础上，这个高度会不断减小，但我们不用去时刻维护它，这样也可以达到最优的时间复杂度是已经被证明的了）。

#### 时间复杂度表格

当并查集中的元素个数为 nn 时，下面的表格给出了单次并查集操作的时间复杂度：

|优化	|平均时间复杂度	|最坏时间复杂度 |
| ---- | ---- | ---- |
|无优化	|O(logn)| O(n) |
|路径压缩	|O(α(n))	|O(logn)|
|按秩合并	|O(logn)	|O(logn)|
|路径压缩 + 按秩合并	|O(α(n))| O(α(n)) |

这里 α 表示阿克曼函数的反函数，在宇宙可观测的 nn 内（例如宇宙中包含的粒子总数），α(n) 不会超过 55。

